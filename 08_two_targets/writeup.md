# 08 Two targets writeup

The binary is a simple reversing challenge, the user input gets bit shifted, xorred and compared to a hardcoded value, so as you can see:

```c
for ( i = 0; i <= 31; ++i )                   // 32
    check[i] = (((unsigned __int8)my_string[i] >> 4) | (16 * my_string[i])) ^ *((_BYTE *)main + (int)i);
```

So we can just reverse the operations and get the flag:

```py
check =   [0x11, 0xDE, 0xCF, 0x10, 0xDF, 0x75, 0xBB,
           0xA5, 0x43, 0x1E, 0x9D, 0xC2, 0xE3, 0xBF,
           0xF5, 0xD6, 0x96, 0x7F, 0xBE, 0xB0, 0xBF,
           0xB7, 0x96, 0x1D, 0xA8, 0xBB, 0x0A, 0xD9, 
           0xBF, 0xC9, 0x0D, 0xFF]

mainxor = [0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 
           0x50, 0x64, 0x48, 0x8B, 0x04, 0x25, 0x28, 
           0x00, 0x00, 0x00, 0x48, 0x89, 0x45, 0xF8,
           0x31, 0xC0, 0xE8, 0x24, 0xFE, 0xFF, 0xFF,
           0x48, 0x8D, 0x45, 0xC0]


main_hexed = [hex(i)[2:].rjust(2,'0') for i in mainxor]
main_bytes = [bytes.fromhex(i) for i in main_hexed]

check_hexed = [hex(i)[2:].rjust(2,'0') for i in check]
check_bytes = [bytes.fromhex(i) for i in check_hexed]

solution = [xor(i, j) for i, j in zip(main_bytes, check_bytes)]
```
And simply send it to the program.

